<?php

namespace Opencontent\Installer;

use ezcConsoleDialogViewer;
use ezcConsoleOutput;
use ezcConsoleQuestionDialog;
use InvalidArgumentException;
use RuntimeException;
use Symfony\Component\Yaml\Yaml;
use Throwable;

class Steps extends AbstractStepInstaller implements InterfaceStepInstaller
{
    private $installerFactory;

    private $steps = [];

    private $runOnlySteps;

    public function __construct(StepInstallerFactory $stepFactory)
    {
        $this->installerFactory = $stepFactory;
        $this->runOnlySteps = [];
    }

    public function setStep($step)
    {
        parent::setStep($step); // TODO: Change the autogenerated stub
        $steps = $step['steps'] ?? null;
        if ($steps === null && isset($step['identifier'])) {
            $file = $this->ioTools->getFileContents("steps/{$step['identifier']}.yml");
            if ($file) {
                $data = Yaml::parse($file);
                $steps = $data['steps'] ?? null;
            }
        }
        if (!is_array($steps)) {
            throw new InvalidArgumentException('Steps not found');
        }
        $this->steps = $steps;
    }

    /**
     * @throws Throwable
     */
    public function dryRun(): void
    {
        $this->loopSteps(true);
    }

    /**
     * @throws Throwable
     */
    public function install(): void
    {
        $this->loopSteps(false);
    }

    /**
     * @throws Throwable
     */
    private function loopSteps(bool $dryRun)
    {
        foreach ($this->steps as $index => $step) {
            $stepName = AbstractStepInstaller::getStepName($step);
            $installer = $this->installerFactory->factoryByType($step['type']);
            $installer->setStepIndex($index);
            $installer->setParentStepInstaller($this);
            $stepIndex = $installer->getStepIndex();
            if ($installer instanceof Steps){
                $installer->setRunOnlySteps($this->runOnlySteps);
            }

            if (!empty($this->runOnlySteps) && !in_array($stepIndex, $this->runOnlySteps, true)) {
                $this->logger->debug("(skip) [$stepIndex] $stepName");
            } else {
                $this->logger->debug("[$stepIndex] $stepName");
                $this->run($installer, $step, $dryRun);
            }
        }
    }

    /**
     * @throws Throwable
     */
    private function run(InterfaceStepInstaller $installer, array $step, bool $dryRun): void
    {
        $ignoreError = false;
        if (isset($step['ignore_error'])) {
            $ignoreError = (bool)$step['ignore_error'];
        }
        if (isset($step['condition'])
            && $step['condition'] == '$is_install_from_scratch'
            && !$this->installerVars['is_install_from_scratch']) {
            $ignoreError = true;
        }

        try {
            $canInstallByVersionConstraint = $this->isStepInstallableByVersionConstraint($step);

            if ($canInstallByVersionConstraint) {
                $installer->setStep($step);

                $skip = false;
                if (isset($installer->getStep()['condition'])) {
                    $condition = $installer->getStep()['condition'];
                    if ((bool)$condition !== true) {
                        $this->logger->debug(" -> skipped by condition parameter");
                        $skip = true;
                    } else {
                        $this->logger->debug(" -> valid condition parameter");
                    }
                }

                if (!$skip) {
                    if ($dryRun) {
                        $installer->dryRun();
                        if ($this->installerFactory->isWaitForUser() && !$this->waitForUser('  -> next step?')) {
                            throw new RuntimeException('Aborted');
                        }
                    } elseif ($this->installerFactory->isWaitForUser()) {
                        $installer->dryRun();
                        if ($this->waitForUser(' -> install step?')) {
                            $installer->install();
                        }
                    } else {
                        $installer->install();
                    }
                }
            }
        }catch (InvalidArgumentException $e) {
            // InvalidArgumentException are always thrown
            throw $e;
        } catch (Throwable $e) {
            if ($ignoreError) {
                $this->getLogger()->error($e->getMessage());
            } else {
                throw $e;
            }
        }
    }

    public function appendStep(array $step): void
    {
        $this->steps[] = $step;
    }

    public function setSteps(array $steps): void
    {
        $this->steps = $steps;
    }

    private function isStepInstallableByVersionConstraint($step): bool
    {
        $skip = false;
        $currentVersion = $this->installerFactory->getCurrentVersion();
        $countVersionCheck = 0;
        $versionCheckValidCount = 0;
        $skipByVersionDebug = [];

        $availableConditions = [
            [
                'directive' => 'current_version_lt',
                'string_operator' => 'lt',
                'operator' => '<',
            ],
            [
                'directive' => 'current_version_le',
                'string_operator' => 'le',
                'operator' => '<=',
            ],
            [
                'directive' => 'current_version_eq',
                'string_operator' => 'eq',
                'operator' => '=',
            ],
            [
                'directive' => 'current_version_ge',
                'string_operator' => 'ge',
                'operator' => '>=',
            ],
            [
                'directive' => 'current_version_gt',
                'string_operator' => 'gt',
                'operator' => '>',
            ],
        ];

        foreach ($availableConditions as $condition) {
            $directive = $condition['directive'];
            if (isset($step[$directive])) {
                $check = version_compare(
                    $currentVersion,
                    $step[$directive],
                    $condition['string_operator']
                );
                if ($check) {
                    $versionCheckValidCount++;
                }
                $skipByVersionDebug[$directive] = implode(' ', [
                    $currentVersion,
                    $condition['operator'],
                    $step[$directive],
                    '->',
                    (int)$check,
                ]);
                $countVersionCheck++;
            }
        }
        if ($countVersionCheck > 0) {
            foreach ($skipByVersionDebug as $skipCond => $skipDebug) {
                $this->logger->debug(" -> version compare: $skipCond $skipDebug");
            }
            $skip = $countVersionCheck != $versionCheckValidCount;
            if ($skip) {
                $this->logger->debug(
                    " -> skipped by version compare parameters ($versionCheckValidCount/$countVersionCheck)"
                );
            }
        }

        return $skip === false;
    }

    private function waitForUser(string $question): bool
    {
        return ezcConsoleDialogViewer::displayDialog(
                ezcConsoleQuestionDialog::YesNoQuestion(
                    new ezcConsoleOutput(),
                    $question,
                    'y'
                )
            ) === 'y';
    }

    public function setRunOnlySteps(array $runOnlySteps): void
    {
        $this->runOnlySteps = $runOnlySteps;
    }
}